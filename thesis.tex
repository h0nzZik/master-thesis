%%%%% Definitions of If- toggles
\newif\ifshowkexamples


%%%%% 
%\showkexamplestrue

%%%%%
\documentclass{fithesis3}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage{syntax}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{subcaption}
%\usepackage{mathtime}

\usepackage[english]{babel}
\usepackage{float} % floating figures
\usepackage{minted}
%\usepackage{amsmath}
%\usepackage{amsfonts}
\usepackage{amssymb} % \rightsquigarrow etc
%\usepackage{makeidx}
%\usepackage{graphicx}

%\usepackage{k}
\usepackage[tight]{k}
% For unknown reason, the drawing is too 'white'
%\usepackage[style=math]{k}


\floatstyle{boxed} 
\restylefloat{figure}


%%%%%%%%%%%%%% Thesis metadata %%%%%%%%%%%%%%%
\thesissetup{
title = {An Executable Formal Semantics of C++},
TeXtitle = {An Executable Formal Semantics of C++},
author = {Jan Tušil},
keywords = {C++ semantics k-framework},
TeXkeywords = {C++ semantics k-framework},
advisor = {Jan Strejček},
gender = {m},
type = {mgr},
faculty = {fi},
%abstract = {Here will be an abstract},
%thanks = {Special thanks to...}
%bib = {references.bib}
}

%\addbibresource{references.bib}

%% Some math aliases
\newcommand{\var}[1]{\mathit{#1}}


% Notes about the 'k' package
% \ka{rule x => y} - inline K in ascii format
% \begin{asciik} rule x => y \end{asciik} - K ascii environment
% Displaying open/closed bubbles
% \kall{1}{2}{3}, \kprefix{1}{2}{3}, \ksuffix{1}{2}{3}, and \kmiddle{1}{2}{3}

\begin{document}

\chapter{Introduction}

% Uz tady bych chtel nastinit vztahy mezi K frameworkem, operacni semantikou a C++. Ale jenom zlehka, aby ctenar mel intuitivni predstavu o tom, o cem bude zbytek textu, stejne jako to, cim jsem ja prispel. Hlavne by tu mela byt motivace. co delam? Rozsiruji formalni semantiku jazyka C++ v K, ktera jeste neni dokoncena. Proc to delam? Asi se ztotoznuji s tim, ze verifikacni metody a semantika mohou byt oddelene, a ze mit formalni semantiku, o niz je mozne strojove uvazovat, je uzitecne. Na jakou praci navazuju?

% Pry bych mel uvest, co je zname a co je nezname. Mno zname je vsechno - je mozne vytvorit semantiku realneho jazyka, jak bylo demostrovano na pripade C, Javy, JavaScriptu etc. Jen je potreba to udelat pro C++. 

\section{Motivation}

\section{Related work}
% Jak k semantice C/C++, tak k jejich verifikaci
For example, Javascript semantics \cite{park-stefanescu-rosu-2015-pldi}.
%Other C++ Also tell something about other approaches to verifying C++ (which is my main motivation for having the semantics).
Norrish - small step structural C++ semantics in HOL (isabelle/coq?)


\chapter{Background}
% Ok,  Co musi ctenar vedet? Musi mit nejakou predstavu o operacni semantice, pak o tom, jak lze v K popisovat jazyky. Potom musi trochu znat C++, ze mame nejakou kompilaci, linkovani, ze je to kompatabilni s C castecne na zdrojove, castecne na link-time urovni.

\section{Operational semantics}
Mozna neni nutne. Ctenari pravdepodobne budou znat. Odkazy na nejake dokuemnty/kurzy?


\section{K framework}

The purpose of this section is to give an overview of \K semantic framework. First subsection shows, how \K can be used to describe language semantics in an operational manner; the second subsections contains an overview of various \K tools, including debugger, as well as a brief introduction of \K abstract syntax; the last subsection discuss in more detail various aspects of \K, including matching and reachability logic.

\subsection{Idea}
Mozna neni treba, mozna ze 
\K framework idea - see their image.

%We have to also mention that K framework can parse concrete syntax but it can also be used with an external parser.


% KAst
% 

% Taky bych chtel popsat, jake nastroje K framework nabizi, z ceho se sklada apod. Ale ze aktualni prochazi rekonstrukci, takze nektere vlastnosti nefunguji. Pdf dokumentace ze semantiky. Obycejny interpreter, model checker, ...



\subsection{K And Operational semantics}

%Goal: to show, how K framework fits to operational semantics. How various K construct support specifying syntax, rewrite rules, configurations, ...

%(Informal semantics of many programming languages is defined in this way.) 


%TODO add a note about ascii/latex K
%\begin{asciik}
%| "if" BExp "then" Stmt "else" Stmt "fi" [strict(1)]
%\end{asciik}

In \K framework, languages are described using small-step operational semantics. Small step operational semantics assigns to every program a transition system $( \var{Cfg}, \rightarrow )$ over the set of program configurations, whose transitions correspond to computational steps. Existence of transitions between given configurations is then determined e.g. by some deductive system (in case of structural operational semantics), or by pattern matching rewriting rules to the configurations (in case of \K).


%TODO reference some courses and lecture notes for small-step structural operational semantics
%TODO cite the k tutorial

Program configurations for small-step semantics can consist of a ,,program'' part and a ,,data'' part. Consider simple imperative language IMP. In textbook small-step SOS, the set of program configurations $\var{Cfg}$ can be defined as $\var{Pgm} \times \Sigma$, where $\var{Pgm}$ is a set of programs and $\Sigma$ is the set of functions from variable names to (syntactic) integers; thus, configurations are tuples. In \K, configurations are made of \textit{cells} nested in a tree-like manner; the cells contain a values of various predefined (numbers, lists, \ldots) or user-defined syntactic sorts. Every configuration is then a (ground) term.

The configuration for IMP can be defined as in figure~\ref{ImpConfigurationInK}. The \texttt{k} cell contains the ,,program'' part - a list of computations yet to be computed. The \texttt{state} cell holds a map from variable names to values; the syntactic sorts of its keys and values are not specified. The \texttt{state} cell initially holds an empty map, while \texttt{k} cell initially contains the abstract syntax tree of whole program.

The abstract syntax is defined using BNF notation inside \texttt{syntax} declarations (see figure~\ref{ImpSyntaxInK}). \K also supports attaching various attributes; some of them (e.g associativity attributes) are needed to support automatic generation of concrete syntax parser, some of the other have a semantic impact (strictness attributes etc). Note that the user-defined syntactic constructs can be used anywhere in configuration, not just in \texttt{k} cell.

\begin{figure}
\caption{Definition of program configuration in the syntax of \K. }
\label{ImpConfigurationInK}
\begin{asciik}
configuration <T> <k> \$PGM:Pgm </k> <state> .Map </state> </T>
\end{asciik}
\end{figure}

\begin{figure}
\caption{Part of IMP syntax in \K. The syntactic categories $\var{Id}$, $\var{Int}$ are predefined as well as some operations on them. }
\label{ImpSyntaxInK}
\begin{asciik}
syntax AExp ::= Id | Int

syntax BExp  ::= Bool
| AExp "<=" AExp [seqstrict]

syntax Stmt  ::= "skip"
| Id "=" AExp
| "if" BExp "then" Stmt "else" Stmt "fi" [strict(1)]
\end{asciik}
\end{figure}


%TODO note about syntactic domains Id and Bool.


%TODO say that configuration cells have their own sort

%The $<k>$ cell contains a sequence of commands to execute. $c_1 \rightsquigarrow c_2$.

% Nejdrive tak intuitivne
The transition system is induced by rewriting rules; those have the form of $l \Rightarrow r \texttt{ if } b$, where $l$ and $r$ are matching-logic patterns \footnote{Patterns are basically terms with free variables. Details about matching logic are given in \ref{MatchingLogic}.},
%(terms with free variables) of the same sort, 
and $b$ is a first-order formula over free variables of $l$. Whenever the pattern $l$ \textit{matches} a configuration such that $b$ evaluates to $\var{true}$, the rule gets applied and generates a new configuration. One such rule in the IMP language may be
\begin{asciik}[basicstyle=\small]
rule <T><k> X:Id => I ...</k>
     <state>... X |-> I ...</state></T>
\end{asciik}


%FIXME the rule does not match always,

% Pozdeji presneji.
%The transition system contains transition between configurations $C_1$ and $C_2$, if there
%The rule gets applied whenever the pattern $l$ \textit{matches} the current configuration, i.e. it is possible to substitute free variables in $l$ for ground terms such that the result is identical to the configuration, and $b$ (after the same substitution) holds.  Due to the mechanism called ,,configuration abstraction'', rules can be unified with a subtree of the configuration, thus avoiding a use of unnecessary subterms in the rule.

Many rules care about only a small fraction of the configuration. \K framework therefore implements a mechanism called ,,configuration abstraction'', which allows rules to mention only the necessary configuration cells; \K then desugars them. For example, in the above rule it is possible to remove the $<T>$ cell.


%$\kprefix{k}{\reduce{X:Id}{I}...}{}$
%$\kall{1}{2}{3}$

%TODO cite some source of matching logic, configuration abstraction etc.

%TODO contexts, heating/cooling rules, strictness

%TODO difference between \K source code and latex drawing (it is used everywhere).

%TODO structural frames (I heard about them in the Java semantics)



Those three kinds of \K declarations are sufficient to give a semantics to given language; however, \K provides some additional construct, which makes writing the semantics easier. Those will be discussed in latter sections


% Mozna i nejake jazykove vyrazy toho jazyka. Kontexty, [function] - sam tomu presne nerozumim.
\subsection{Parsing and K AST}
TODO: something about k abstract syntax format, concrete syntax parser, the possibility to use external parsers. This is what we do in the C++ semantics.

\subsection{Semantics in K}
\subsection{Matching and reachability logic}

%Protoze moji motivaci je v konecnem dusledku verifikace, mel bych zminit, ze existuje matching logika a hlavne reachability logika spolu s odvozovacim systemem. Idealne se zase odvolat do nejakeho paperu. Urcite bych to nepopisoval.

\section{C++}

% Popisu C++ bude trochu odpovidat struktura projektu C/C++ semantiky. Mame tam oddelenou statickou a dynamickou semantiku. Jak to souvisi se standardem? Je toto oddeleni bezne? Maji to ostatni K semantiky?
% Taky v te semantice vyznacujeme, co je undefined, unspecified, implementation defined behaviour. I semantika enumu to vyuziva

% Kde se nachazi normativni dokumenty? Na jakem je zalozena ta semantika? Neco k jejich strukture?

\subsection{Standard documents}

About standards. How they are accessible etc.

\subsection{Phases of translation}
\label{txt:phases-of-translation}
% Jeden odstavec neformalniho popisu, jeden odstavec formalniho
Real-world C++ programs usually consist of multiple source files. To build the program, the source files are compiled one by one and resulting object files are then linked together. It is also possible to link compiled C file with the C++ program. Building a program is a multiple-step process.

% Nejaky priklad

Although C/C++ standards does not go to implementation details, they contain the idea of translation phases and separate translation. Translation unit (according to ???) is a source file with its \textit{include} files included. Section 2.2 of the C++14 standard identifies 9 translation phases; the first five or six of them are usually refferred to as \textit{preprocessing phases} (or one \textit{preprocessing phase}) , in the seventh phase the compilation of single translation unit takes place, phase number eight deals with template instantiation and in the ninth phase the whole program is linked together. In C language the phases are similar (but phase eight is missing).

\subsection{Interoperability with C}

\subsection{Basic concepts}

% Zminit nekde to, ze C++ hodne mluvi o tom, kdy je program nedefinovany... jak o tom mluvi v "Defining the Undefinedness of C ∗"

\chapter{C++ semantics in K}
% Neco o historii projektu, ze prvne byla C semantika (2012). Jak to pasuje do K frameworku i do jazyka C++. Ze 'oni' (kdo?) udrzuji fork K a ocaml backend. 
% Je nejaka moznost, jak vypnout diagnostiku u toho CLang parseru? Jo popsat K AST format.

% Taky tadu musim podrobneji rozebrat, co jsem vlastne udelal. Mno zatim toho moc neni.
% Taky za na tom RuntimeVerification, inc. stavi nejake produkty - RV-match?

% Co je vlastne spolecneho s C semantikou?
% point to https://github.com/kframework/c-semantics
% TODO data flow diagram jako je v Defining the Undefinedness of C.


\section{Intro, history}

\section{Basic usage}

\section{Structure of the project}

%Ze ta semantika se sklada z vice 'projektu'? Nebo 'semantik'? Nebo jak oni to nazyvaji. kcc/k++ skripty. Jo a parser zalozeny na CLang. Language definitions

% Tady bych chtel popsat, jake vsechny soucasti ta semantika pouziva. K framework a utility z neho (krun). ocaml backend. A zminim se i o rv-match? Kazdopadne je treba se zminit o tom, ze mame vicero zkompilovanych semantik, protoze se na ne pak odkazuji.

The project of C/C++ semantics is made of multiple modules, which are introduced in this section. 
%It also depends on some external tools.
Its main user interface consists of a script named kcc, which implements a semantics-based compiler. In fact, the script mimincs the interface of the gnu gcc compiler and supports many of gcc's command-line parameters. It is possible to use it to build programs instead of gcc; however, the generated executables are many times slower then the ones built with gcc.

The figure~\ref{fig:cpp-program-example} contains a simple program, consisting of one C and one C++ source file. When compiled with gcc, it first compiles both source files separately, storing the resulting object code in separate object files, and then links the object files to final executable. The kcc script invoked by command
\begin{lstlisting}[language=bash]
$ kcc foo.c main.cpp -o hello
\end{lstlisting}
works similarly. Analogically to gcc, the build process can be decomposed into the following commands:
\begin{lstlisting}[language=bash]
$ kcc -c foo.c -o foo.o
$ kcc -c main.cpp -o main.o
$ kcc foo.o main.o -o hello
\end{lstlisting}
% NOTE: we may use just CC there and refer to gcc or kcc? But what about g++?

When the first two commands are executed, a \textit{translation} takes place, whereas executing the third command performs \textit{linking}. During the translation, all translations phases described in C/C++ standard (see section~\ref{txt:phases-of-translation}) are performed, except the last one (the eight in case of C, the ninth in case of C++), which is performed during the linking.

During the translation, kcc first uses the gcc compiler (gcc -E) to perform the preprocessing phases. The preprocessed files are then converted to K AST using separate parsers. (The project contains two tools for this purpose: the older one, \textit{cparser}, is based on OCaml CIL library\footnote{https://github.com/cil-project/cil} and supports only C language; the newer \textit{clang-kast} based on Clang\footnote{http://clang.llvm.org/} llvm fronted was created specifically for the C++ semantics, but it might be used for C in future.)
Resulting K AST files are then \textit{krun} using a \textit{static semantics} module for the appropriate language; the result is then stored in object files, again with use of the K AST format.

In the linking phase, kcc first joins all the compiled object files together. The joined object file is then krun using combined C and C++ \textit{execution semantics} module, but with use of a K ocaml backend. This backend first compiles the program to an ocaml source file, which is then compiled with regular ocaml compiler (ocamlopt) to native code stored in ELF format. The resulting executable can be then normally run.

\begin{lstlisting}[language=bash]
$ ./hello
\end{lstlisting}

% which drives semantics-based compilation and mimics the interface of gcc.
% Like GCC does, the script is able to compile C/C++ source files to intermediate format (conceptually similar object file) and to link the resulting files together.


\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering

\begin{lstlisting}{language=C++}
class C{};
extern "C" int foo(int);
int main() {
	return foo(5);
}
\end{lstlisting}

  \caption{Main C++ source file (main.cpp)}
  %\label{fig:sub1}
\end{subfigure}%
%\unskip\ \vrule\
\begin{subfigure}{.5\textwidth}
  \centering
\begin{lstlisting}{language=C}
struct S{int a};
S s {.a = 3};
int foo(int x) {
	return x * s.a;
}
\end{lstlisting}
  \caption{C99 source file (foo.c)}
  %\label{fig:sub2}
\end{subfigure}
\caption{A mixed C/C++ program. Note that the C source file uses a feature (designated initializers), which is not supported in C++, and vice versa.}
\label{fig:cpp-program-example}
\end{figure}


To sum up, the C/C++ semantics project consists of: one parser for C and another one for C++; one K module implementing static semantics of C and another one for C++; a separate module for the dynamic semantics of both C and C++; and a script kcc, which drives the compilation.

%As described in (???), K framework is able to generate a compiler/interpreter for given language definition. 

% Taky bych mel rict, co vlastne dela takova semantika v K. Ona dostane nejakou inicialni konfiguraci, bezi, a na konci skonci v cilove konfiguraci. Takovymto zpusobem je mozne napsat semantiku, ktera jakoby preklada kod. Jedna takova semantika muze odpovidat fazi prekladu translacni jednotky...

%C and C++ languages have a lot in common. It is easy to use them together in one project. Some C sources can be compiled as C++ and it 'works'; of course, many can not. It is possible to link C libraries to C++ programs, and even to call C++ functions from C.

%Jak funguje ten preklad: to by asi melo byt v kapitole o C++. Standard v 2.2 definuje 9 fazi prekladu. Prvnich 6 je takzvany preprocesing, potom 7 - preklad translacni jednotky. Taky tu jsou instanciacni jednotky - to je pro sablony? 8 - kmobinace translacni a instanciacnich jednotek. 9 - linkovani. Linkovani je pak popsano v 3.5. C to ma podobne.ioi

%The K C++ semantics emerged from the project of C semantics and it shares a repo with it. It consists of the following parts: clang-based C++ parser, linking semantics, ... and a set of scripts driving the compilation. Static semantics 


% Naznacit, co patri kam. Jako ze name lookup je soucasti staticke semantiky, vyhodnocovani vyrazu je soucasti dynamicke (prestoze nektere casti jsou i soucasti staticke, a pribude constexpr). Ridici smycky - dynamicke.


% Kdyz tedy mluvime o kompilaci, asi bych mel zminit, ze K umoznuje 'snadno' udelat ze semantiky interpreter.

% Taky to mozna muzeme nazvat 'implementace'
\chapter{Contribution and evaluation}
	

TODO mention some GCC/clang tests

\chapter{Conclusion}
	
\chapter{Zbytek}

Some ideas about \K framework. Verifier for all languages. Etc. Also note that transitions in C++ semantics are often more low level then the usual (programmer's) reasoning about the code. By the way, \K supports reduction contexts (for operational semantics). And some \K paper says that it is possible to use various styles of semantics, e.g. Big Step, reduction contexts, \ldots . Link to \K tutorial. K AST (kast).

\ifshowkexamples
Some K examples:

% When style is 'math', it has to be in $$.
$\kall{name}{content}{X > 3}$,

\kprefix{name}{content}{X > 3},

\ksuffix{name}{content}{X > 3},

and \kmiddle{name}{content}{X > 3}.

$\mmiddle{blue}{content}{X > 3}$
\bmiddle{blue}{content}{X > 3}.

\fi




\end{document}